#!/bin/bash

#    Copyright 2018 Juliano Santos [SHAMAN]
#
#    This file is part of bashsrc.
#
#    bashsrc is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    bashsrc is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with bashsrc.  If not, see <http://www.gnu.org/licenses/>.

[[ $__SOCKET_SH ]] && return 0

readonly __SOCKET_SH=1

source builtin.sh

declare -a __SOCKET_INFO_CONN

readonly __SOCKET_MAX_CONN=1024					# limite de conexões
readonly __SOCKET_FLAG_PROTOCOL='@(tcp|udp)'

# Tipo
__TYPE__[socket_t]='
socket.socket
socket.connect
socket.fileno
socket.peername
socket.port
socket.proto
socket.close
socket.send
socket.recv
'

var sockaddr_t      struct_t

# Estrutura de conexão.
sockaddr_t.__add__      port        uint        \
                        protocol    flag        \
                        address     str

# func socket.socket <[var]sock> <[sockaddr_t]address> => [bool]
#
# Cria soquete de conexão com o host apontado na estrutura 'address' e salva
# o descritor em 'sock'.
#
function socket.socket()
{
    getopt.parse 2 "socket:var:+:$1" "address:sockaddr_t:+:$2" "${@:3}"

    local __fileno
    
	# Estrutura de conexão
    local   __port=$($2.port)       \
            __proto=$($2.protocol)  \
            __addr=$($2.address)

	if [[ ! $__port || ! $__proto || ! $__addr ]]; then
        error.trace def 'address' 'sockaddr_t' '' 'falha ao definir a estrutura de conexão'
        return $?
	elif [[ $__proto != $__SOCKET_FLAG_PROTOCOL ]]; then
		error.trace def 'address' 'sockaddr_t' "$__proto" 'protocolo invalido'
		return $?
	fi
		
    # Obtem o descritor disponível.
    for ((__fileno=0; i <= __SOCKET_MAX_CONN; __fileno++)); do
        [[ -t $__fileno ]] || break
    done

    if [[ $__fileno -eq $__SOCKET_MAX_CONN ]];  then
        error.strerror 1 'limite máximo de conexões alcançado'
        return $?
    fi
	
	__SOCKET_INFO_CONN[$__fileno]="$__fileno|$__proto|$__addr|$__port"
	printf -v $1 '%d' $__fileno
	
    return $?
}

# func socket.connect <[uint]sock> <[uint]timeout> => [bool]
#
# Conecta 'sock' ao host remoto em 'timeout' segundos.
# Obs: finaliza a conexão caso o tempo limite seja excedido.
#
function socket.connect()
{
	getopt.parse 2 "sock:uint:+:$1" "timeout:uint:+:$2" "${@:3}"
	
	local sock_attr conn pid

	socket.__check_socket $1 || return $?

	mapfile -td'|' sock_attr <<< ${__SOCKET_INFO_CONN[$1]}
	conn="${sock_attr[0]}<>/dev/${sock_attr[1]}/${sock_attr[2]}/${sock_attr[3]}"

	# Testa conexão (thread)
	eval exec "$conn" &>/dev/null &

	pid=$!
	sleep $2

	if kill -SIGCHLD $pid &>/dev/null; then
	       	error.format 1 "não foi possível conectar em '%s:%s'" "${sock_attr[2]}" "${sock_attr[3]%?}"
        	return $?
	fi
	
	eval exec "$conn" &>/dev/null
		
	return $?
}

# func socket.fileno <[uint]sock> => [uint]
#
# Retorna um inteiro que representa o descritor de arquivo do socket.
#
function socket.fileno()
{
	getopt.parse 1 "sock:uint:+:$1" "${@:2}"

	socket.__check_socket $1 || return $?
	
	local sock_info

	mapfile -td'|' sock_info <<< ${__SOCKET_INFO_CONN[$1]}
	echo "${sock_info[0]}"

	return $?	
}

# func socket.peername <[uint]sock> => [str]
#
# Retorna o endereço do host remoto vinculado ao soquete.
#
function socket.peername()
{
	getopt.parse 1 "sock:uint:+:$1" "${@:2}"

	socket.__check_socket $1 || return $?
	
	local sock_info

	mapfile -td'|' sock_info <<< ${__SOCKET_INFO_CONN[$1]}
	echo "${sock_info[2]}"

	return $?	
}

# func socket.port <[uint]sock> => [uint]
#
# Retorna a porta do soquete.
#
function socket.port()
{
	getopt.parse 1 "sock:uint:+:$1" "${@:2}"

	socket.__check_socket $1 || return $?
	
	local sock_info

	mapfile -td'|' sock_info <<< ${__SOCKET_INFO_CONN[$1]}
	echo "${sock_info[3]%?}"

	return $?	
}

# func socket.proto <[uint]sock> => [str]
#
# Retorna o protocolo de conexão do soquete.
#
function socket.proto()
{
	getopt.parse 1 "sock:uint:+:$1" "${@:2}"

	socket.__check_socket $1 || return $?
	
	local sock_info

	mapfile -td'|' sock_info <<< ${__SOCKET_INFO_CONN[$1]}
	echo "${sock_info[1]}"

	return $?	
}

# func socket.close <[uint]sock> => [str]
#
# Fecha o soquete de conexão.
#
function socket.close()
{
	getopt.parse 1 "sock:uint:+:$1" "${@:2}"

	socket.__check_socket $1 || return $?
	
	eval exec "$1<&-"
	unset __SOCKET_INFO_CONN[$1]
	
	return $?
}

# func socket.send <[uint]sock> <[str]msg> => [bool]
#
# Envia mensagem ao soquete.
#
function socket.send()
{
    getopt.parse 2 "sock:uint:+:$1" "msg:str:+:$2" "${@:3}"

	socket.__check_socket $1 || return $?

    echo -e "$2" >&$1

	return $?
}

# func socket.recv <[uint]sock> <[int]buffsize> => [str]
#
# Recebe até 'buffsize' bytes de 'socket'.
# Se buffsize < 0 lê todos os bytes.
#
function socket.recv()
{
	getopt.parse 2 "sock:uint:+:$1" "buffsize:int:+:$2" "${@:3}"
	
	socket.__check_socket $1 || return $?

	local bytes

	if (($2 > 0)); then
		read -N$2 -u $1 bytes
		echo "$bytes"
	else
		while read bytes <&$1; do
			echo "$bytes"
		done
	fi

	return $?
}

function socket.__check_socket()
{
	[[ ${__SOCKET_INFO_CONN[$1]} ]] || error.trace def 'var' 'socket' "$1" 'soquete não encontrado'
	return $?	
}

source.__INIT__
# /* __SOCKET_SH */

